#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Mover - the script for archiving the data
@author: Milos Korenciak"""

from __future__ import print_function
import glob
import shutil
import time
import traceback

from general_utils.basic_lock import *


class DummyError(Exception):
    pass


try:  # compatibility of Py3.4+ with <Py3.4
    _ = FileExistsError()  # test if we have FileExistsError avialable
except NameError:
    FileExistsError = DummyError
try:  # compatibility of Py3.4+ with <Py3.4
    _ = FileNotFoundError()  # test if we have FileExistsError avialable
except NameError:
    FileNotFoundError = DummyError
# make logger
logger = make_logger(__name__)
logger.setLevel(1)


# config ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
def default_filepath2datetime(file_name):
    """Default method returning the last modify time of the file as POSIX UTC timestamp"""
    posix_time = os.path.getmtime(file_name)  # thi returns UTC timestamp of modify time
    return posix_time


CONSTANTS = {
    # Mail the error stacktrace to this people if the downloader crashes
    "ADMINS_OF_MOVER": ['milos.korenciak@geomodel.eu', 'ioan.ferencik@geomodel.eu', 'tomas.cebecauer@geomodel.eu'],
    # Credentials to connect to given FTP
    "LATENCY": 60,  # IN SECONDS! move the files older then 0 days
    "MOVE_DICT": {"/tmp/a/": "/tmp/b/",
                  # "/data/HIMAWARI8_OPERATIONAL/INCOMING": "/net/titan/data/HIMAWARI8_OPERATIONAL/INCOMING",
                  },
    # add recursively this dir struture
    # for dirpath, dirnames, filenames in os.walk("/tmp/aha"):
    #     MOVE_DICT[dirpath] = "/tmp/ihi"
    # File patterns to check
    "PATTERNS": ["*.nc"],
    # Whether to enforce directory structure YYYY/mm/{files}
    "DIR_STRUCTURE_TIMESLICING": False,
    # the method getting absolute file path; required to return POSIX UTC timetamp file belongs to
    "GET_FILE_TIME": default_filepath2datetime,
}


#
# end of config ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


def is_running(name=None, ipid=os.getpid()):
    """Checks is the python  script "name" is running. Basically this functions should be used
    from within the same script
    If the script is running:
        returns True, pid, string representing the running time in format [[dd-]hh:]mm:ss
    else
        If is not running returns False, None, None

    @args:
        @name, str, the name of program|script
        @ipid, int, the rocess id of the"""
    if not os.path.isabs(name):
        raise ValueError, 'The script name "%s" is not an absolute path' % name
    py_processes = os.popen("ps aux |grep python").read()
    exists, pid, start_time_string = False, None, None
    for pline in py_processes.splitlines():
        if name in pline:
            pid = int(pline.rsplit()[1])
            if pid != ipid:
                start_time_string = os.popen('ps -p %s -o etime=' % pid).read().strip()
                exists = True
                break
        if exists:
            break
    return exists, pid, start_time_string


def free_bytes_count(dir):
    """Returns bytes available in the dir"""
    statvfs = os.statvfs(dir)
    return statvfs.f_frsize * statvfs.f_bavail


def get_file_size(file_path):
    """Tries to get file size file_ . If error occurs, return -1
    :param file_: file in ftp_dir on ftp server
    :param dir_: ftp_dir
    :return: file size in bytes or -1 (=ignore file size checking)"""
    try:
        return os.path.getsize(file_path)
    except OSError as e:
        # logger.warning("Bad file size. Is not file? " + file_path + "error" + str(e))
        return -1


def get_file_list(patterns, dirs):
    """Coroutine iterting over the files to be possibly moved (this checks only the pattern)"""
    # Iterate over ftp directory at second
    for pattern in patterns:
        logger.debug("pattern %s" % pattern)
        for dir_ in dirs:
            # iterate over the list of files with given pattern
            for file_path in glob.iglob(os.path.join(dir_, pattern)):
                file_name = os.path.basename(file_path)
                yield dir_, file_name


def move_one_file(file_, from_dir, to_dir, filepath2timestamp, dir_structure_timeslicing=False):
    """Processing of one file: download it and write it to the DB
    :param file_: just file name of file to be moved from from_dir --> to_dir
    :param from_dir: directory to move file from
    :param to_dir: directory to move file to
    :return: None
    :raise: Exception if something went wrong - permissions, ..."""
    # at 1st - download the file
    from_file = os.path.join(from_dir, file_)

    if to_dir == os.devnull:
        os.remove(from_file)
        return

    if dir_structure_timeslicing:
        posix_timestamp = filepath2timestamp(from_file)
        datetime_ = datetime.datetime.fromtimestamp(posix_timestamp)
        year, month = datetime_.year, datetime_.month
        to_dir = os.path.join(to_dir, "%04d" % year, "%02d" % month)
        try:
            os.makedirs(to_dir)
        except OSError:
            pass
    logger.debug("move_one1 moving file " + file_ + " from " + from_dir + " to " + to_dir)

    from_file_size = get_file_size(from_file)
    to_file = os.path.join(to_dir, file_)
    to_file_size = get_file_size(to_file)
    # print("from_file_size", from_file_size, "to_file_size", to_file_size)
    if free_bytes_count(to_dir) <= from_file_size:
        raise OSError("Not enought disk space!")
    if to_file_size > -1:
        raise OSError("File " + file_ + " exists yet in DEST dir " + to_dir + " with diferent size")
    if from_file_size > to_file_size == -1:
        shutil.copy2(from_file, to_file)
    # assert the same file sizes before deletion ! Else do not delete the original file
    assert from_file_size == get_file_size(to_file), "Destination file corrupted! Orig " + from_file + " dest" + to_file
    os.remove(from_file)


def scan_and_move(latency, move_dict, filepath2timestamp, dir_structure_timeslicing=False, patterns=["*.nc"]):
    """Core method of this script - check each dir for each pattern and copy the file.
    After copying, compare the sizes - if they do not differ, remove the original file
    :param latency: datetime.timedelta - the moved file mustbe at least this time old to be moved
    :param move_dict: dictionary of directories {dir_from : dir_to}
    :param dir_structure_timeslicing: True/False - whether to enforce dir_t/year/month/ tree structure
    :param patterns: only files matching one (or more) of them can be moved
    :param filepath2timestamp: method getting the datetime from filename
    :return: None"""
    logger.info('s&m1 Going to check the files if anything to move')
    unsuccessful_moves = []
    hostname = os.uname()[1]
    logger.debug("s&m1.1 move_dict: %s" % move_dict)
    for from_dir, to_dir in move_dict.items():
        for dir_, file_ in get_file_list(patterns=patterns, dirs=[from_dir]):
            from_file = os.path.join(dir_, file_)
            logger.debug("s&m2 treating file " + from_file)
            #  + "filepath2timestamp(from_file) %s , time.time() %s, latency %s",
            # filepath2timestamp(from_file), time.time(), latency)
            if filepath2timestamp(from_file) >= time.time() - latency:
                logger.debug("s&m2.5 file " + from_file + " too young")
                continue
            # logger.debug("s&m2.5 treating file " + from_file)
            try:
                move_one_file(file_, dir_, to_dir, filepath2timestamp=filepath2timestamp,
                              dir_structure_timeslicing=dir_structure_timeslicing)
            except (SystemError, SystemExit, KeyboardInterrupt) as e:
                raise e  # Provides Ctrl-C responsive processing
            except (OSError, FileNotFoundError) as e:
                unsuccessful_moves.append(os.path.join(dir_, file_))
                logger.error("s&m3 Problem with " + file_ + "\nError " + str(e))
            except Exception as e:
                logger.error("s&m4 Unspecific error occured: " + str(type(e)) + str(e))
                raise e
    if unsuccessful_moves:
        files_list_str = "\n".join(unsuccessful_moves)
        logger.error("s&m5 This files were not moved and should be:\n" + files_list_str)
        message = "The script '{}' on host {} was unable to move files:\n".format(__file__, hostname)
        message += files_list_str
        basic_mail.mail_process_message_ssl(sender_from='Mover on ' + hostname,
                                            reciever_to=CONSTANTS["ADMINS_OF_MOVER"],
                                            subject='Mover warning',
                                            message=message)
    else:
        logger.info("s&m6 All files were moved correctly!")


def main(main_file_path):
    # ## Process locking - The process must be SINGLETON = max 1 instance in any time!
    hostname = os.uname()[1]
    try:
        logger.debug('Checking if %s is running already...' % main_file_path)
        ipid = os.getpid()
        isrunning, pid, start_s_time = is_running(main_file_path, ipid)
        if isrunning:
            if '-' in start_s_time:  # script is running for more than one day, send message
                sday, stime = start_s_time.split('-')
                basic_mail.mail_process_message_ssl(sender_from='Mover on {0}'.format(hostname),
                                                    reciever_to=CONSTANTS["ADMINS_OF_MOVER"],
                                                    subject='Mover warning',
                                                    message='The script %s is running for %s day and %s on %s' % (
                                                        __file__, sday, stime, hostname))
            logger.error('The script is already running... bailing out!')
            sys.exit(1)
        # set files to be downloaded
        if not CONSTANTS["MOVE_DICT"]:
            raise Exception("""You are going to move from no dirs! This is not supported! Add some of them!""")
        scan_and_move(latency=CONSTANTS["LATENCY"], move_dict=CONSTANTS["MOVE_DICT"],
                      filepath2timestamp=CONSTANTS["GET_FILE_TIME"],
                      dir_structure_timeslicing=CONSTANTS["DIR_STRUCTURE_TIMESLICING"], patterns=CONSTANTS["PATTERNS"])
    except Exception as e:
        estr = 'Exception "{0}" occurred in Mover on host {1}. Other info: {2}'.format(traceback.print_exc(e),
                                                                                       hostname,
                                                                                       str(e))
        logger.error(estr)
        basic_mail.mail_process_message_ssl(sender_from='tech@solargis.com',
                                            reciever_to=CONSTANTS["ADMINS_OF_MOVER"],
                                            subject='Mover error on {0}'.format(hostname),
                                            message=estr)
        sys.exit(1)


if __name__ == "__main__":
    """If run from the console"""
    main(os.path.abspath(__file__))
