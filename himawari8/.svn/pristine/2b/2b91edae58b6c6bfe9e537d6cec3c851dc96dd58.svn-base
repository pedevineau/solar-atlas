#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""Himawari8 data classes.
To access some database, PLEASE initialize its connection this way:

import data_classes
data_classes.database.initialize(data_classes.PostgresqlDatabase('mega_production_db'))
# or
data_classes.database.initialize(data_classes.connect(
  'postgresql://postgres:my_password@localhost:5432/my_database'))

If you do not initialize it, in case of any ORM method invocation, the
following error occurs:
Exception: Error, database not properly initialized before opening connection

Note: for performance boost, use pooled Postgres connection
--> http://peewee.readthedocs.org/en/latest/peewee/playhouse.html#pool+
PooledPostgresqlExtDatabase is recommended

@author: Ioanes, Ferencik, Milos Korenciak"""


from __future__ import print_function

try:
    from playhouse.db_url import connect
except Exception as e:
    print("Not possible to import playhouse extension to peewee")

# The app data part
import peewee as pw
# copy some peewee methods/classes into this module
SqliteDatabase = pw.SqliteDatabase
PostgresqlDatabase = pw.PostgresqlDatabase
MySQLDatabase = pw.MySQLDatabase
IntegrityError = pw.IntegrityError
# set temporary placeholder for the DB --> peewee documentation
database = pw.Proxy()


class DBModel(pw.Model):
    """Base class for all DB Object-Relation-Mapped classes
    This is a peewee hack, quite a nice one"""
    def __str__(self):
        """Default str(obj) handling - default writeout"""
        return str(self._data)

    def to_json(self):
        """Default JSON-ize method"""
        return str(dict(zip(map(str, self._data.keys()), map(str, self._data.values()) )))

    @classmethod
    def upsert(cls, data=None):
        with cls._meta.database.transaction():
            query = cls.insert_many(data).upsert(upsert=True)
            query.execute()
        if not cls._meta.database.is_closed():
            cls._meta.database.close()

    @classmethod
    def bulk_upsert(cls, data=None):
        """
        Bulk inserts an iterable of dictionaries into the table
        :param data:
        :return:
        """

        if len(data) == 0:
            raise ValueError, 'Empty input data dictionary'
        cls._meta.database.connect()
        cls._meta.database.begin()

        for d in data:
            try:
                exists = cls.get(cls.file_name == d['file_name'])
                exists.update(**d).where(cls.file_name == d['file_name']).execute()
            except cls.DoesNotExist:

                rec = cls.create(**d)
            except pw.PeeweeException as e:
                # TODO log the error
                cls._meta.database.rollback()
                cls._meta.database.close()
                raise e

        cls._meta.database.commit()
        cls._meta.database.close()

    class Meta:
        """Meta class - for configuration of ORM"""
        database = database


class downloaded(DBModel):
    """The downloaded files"""
    file_name = pw.TextField(null=False, index=True, primary_key=True)
    datetime = pw.DateTimeField(index=True)
    slot = pw.IntegerField(null=True)  # predpocitane
    dfb = pw.IntegerField(null=True)  # predpocitane
    file_size = pw.BigIntegerField()
    channel_name = pw.TextField(index=True)  # char? mapping


class processed(DBModel):
    """The processed files definition"""
    file_name = pw.TextField(null=False, index=True, primary_key=True)
    datetime = pw.DateTimeField(index=True)
    slot = pw.IntegerField(null=True)  # predpocitane
    dfb = pw.IntegerField(null=True)  # predpocitane
    file_size = pw.BigIntegerField()
    channel_name = pw.TextField(index=True)  # char? mapping
    ssp = pw.FloatField(null=True)
    gt = pw.TextField(null=True)
    disk = pw.TextField(null=True)

    class Meta:
        indexes = ((('channel_name', 'datetime'), True),)  # Note the trailing comma!)



def create_tables(fail_silently=True, conn_dict=None):
    processed.create_table(fail_silently=fail_silently)
    downloaded.create_table(fail_silently=fail_silently)




def get_table(table_name=None,  dbengine=None, host=None, port=None,  database=None, user=None, password=None ):
    """
        Gets the python class that corresponds to a table in the database defined by keyword arguments
        the table in the database corresponds to a class in python. Use this class to manipulate (CRUD) the table
        This function needs to be much more robust. The idea is to create a clas on demand using peewee introspection
        tools (see pwiz)
    """
    url = '%s://%s:%s@%s:%s/%s' % (dbengine, user, password, host, port, database)
    db = connect(url)
    try:
        inst = globals()[table_name]
        #inst = table_name
    except KeyError as ke:
        tables = db.get_tables()
        if table_name in tables:
            db.close()
            raise Exception, 'table "%s" exists in the database %s but is not mapped to a python class. ' % (table_name, database)
        else:
            db.close()
            raise Exception, 'table "%s" does not exist in the database %s. Valid table names are %s. ' % (table_name, database, str(tables))
    inst._meta.database = db
    return inst

'''
if __name__ == "__main__":
    # connect to DB and try to create the tables if they do not exist
    # database.initialize(SqliteDatabase(":memory:"))
    database.initialize(SqliteDatabase(DB_NAME))
    create_tables(fail_silently=True)

    import random as ra
    random_datetime = lambda : datetime.datetime(year=ra.randint(2012,2015),
                                  month=ra.randint(1,12),
                                  day=ra.randint(1,28),
                                  hour=ra.randint(0,23),
                                  minute=ra.randint(0,59),
                                  second=ra.randint(0,59) )
    # create some data
    for i in range(500):
        try:
            Downloaded.create(file_name=str(i)+".nc",datetime=random_datetime(),
                 slot=ra.randint(1,143),dfb=ra.randint(0,65536),file_size=ra.randint(512,4096),
                 satellite=SATELLITE_H08,scene_type=FULL_DISC,file_type="nc",channel="vis")
        except IntegrityError as e:
            pass
        except Exception as e:
            print(e)
            raise e

        try:
            n = Processed.create(slot=ra.randint(1, 143), dfb=ra.randint(0, 65536), datetime=random_datetime(),
                                 scantime=random_datetime(), file_size=ra.randint(512,4096), channel="vis",
                                 ssp=140.3535656, resolution=2000.15, cfac=1.0, coff=1.0, lfac=1.0,
                                 loff=1.0, bbox_xmax=1., bbox_xmin=1., bbox_ymax=1., bbox_ymin=1.,
                                 satellite=SATELLITE_H08)
        except IntegrityError as e:
            pass
        except Exception as e:
            print(e)
            raise e

    database.initialize(SqliteDatabase("my_database.db"))
    # goodbay
'''
if __name__ == '__main__':
    dbengine = 'postgresql'
    host = 'himalia'
    db = 'himawari_archive'
    password = 'itNov6'
    user = 'sat_oper'
    port = 5432
    conn_dict = { 'host': host, 'port': port, 'database': db, 'user': user, 'password': password}

    database.initialize(PostgresqlDatabase(**conn_dict))
    print(database.is_closed())
    database.connect()
    r = processed.get()
    print(r)
    print(database.is_closed())
    database.close()
    print(database.is_closed())
    processed.bulk_upsert(data=[r._data])
    print(database.is_closed())


