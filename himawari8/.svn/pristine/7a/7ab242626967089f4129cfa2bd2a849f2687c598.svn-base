#! /usr/bin/env python
"""Make plot of downloaded data for Himawari8
requires output of archive_stat_querry (3dim 1byte array) e.g. archive2005_vis006.dat"""

from __future__ import print_function
import general_utils.daytimeconv as daytimeconv
from datetime import datetime, timedelta, date
import numpy as np
import psycopg2

from general_utils.basic_logger import make_logger
logger = make_logger(__name__)
logger.setLevel(1)


# ## Main function
def main():
    dsn="dbname=himawari_archive host=dbsatarchive user=sat_oper password=itNov6"
    date_start = date.today() - timedelta(60)
    date_end   = date.today() + timedelta(10)

    # "IR730_2000" "IR133_2000" "VIS086_1000" "IR390_2000" "VIS051_1000" "IR860_2000" "IR112_2000"
    # "IR690_2000" "VIS160_2000" "VIS064_0500" "VIS051_2000" "IR124_2000" "VIS229_2000" "VIS047_1000"
    # "VIS064_2000" "IR104_2000" "IR960_2000" "IR620_2000" "VIS047_2000" "VIS086_2000"
    channel_name = "VIS064_2000"
    table_name = "downloaded"  # "downloaded" or "processed"

    data = get_data_from_db(dsn=dsn, table_name=table_name, channel_name=channel_name, date_start=date_start, date_end=date_end)
    (data, (min_slot, max_slot, min_value, max_value)) = make_array(data, date_start=date_start, date_end=date_end)
    # with file("/tmp/a.svg", "w") as fI:
    #     fI.write(create_svg(data, "Himawari8 downloads VIS064_2000", min_slot, max_slot, min_value, max_value, date_start=date_start, date_end=date_end))
    print("Going to plot")
    create_pyplot_ui(data, "Himawari8 downloads for channel VIS064_2000", min_slot, max_slot, date_start=date_start, date_end=date_end)
    # print(create_pyplot_web(data, "Himawari8 downloads for channel VIS064_2000", min_slot, max_slot, date_start=date_start, date_end=date_end))
    # print renderImage(dsn, channel_name="VIS064_2000", forWeb=False, dpi=80)
    print("Finished")


class VisualizerException(Exception):
    """Base exception for any logical problem when visualizing"""
    pass


def get_data_from_db(dsn, table_name, channel_name=None, date_start=date.today()-timedelta(60), date_end=date.today()+timedelta(10), slot_start=None, slot_end=None):
    """Generator / Coroutine giving tuple (date, slot_integer, file_size) for each filtered row
    :param dsn: PostgreSQL connection string
    :return: yields tuple (date, slot_integer, file_size)"""
    aD_start=date_start.strftime("%Y-%m-%d %H:%M:%S")
    aD_end=date_end.strftime("%Y-%m-%d %H:%M:%S")
    query="""SELECT file_size, datetime, slot
    FROM """ + table_name + """
    WHERE datetime>='{}'
    AND datetime<='{}' """.format(str(aD_start), str(aD_end))
    if slot_start and slot_start:
        query += """ AND slot>={}
        AND slot<={} """.format(str(slot_start), str(slot_end))
    if channel_name:
        query += """ AND channel_name='{}' """.format(channel_name)
    query += """ ORDER BY datetime, slot"""
    conn = psycopg2.connect(dsn=dsn)
    # import sqlite3 as sql
    # conn = sql.connect("/home/m/kodenie/GMS/local_sql.db")
    try:
        curs = conn.cursor()
        curs.execute(query)
        for row in curs.fetchall():
            file_size = row[0]
            datetime__ = row[1]  # unicode representation
            slot = row[2]
            if isinstance(datetime__, basestring):
                date_ = date(*[int(i) for i in datetime__.split()[0].split("-")])
            elif isinstance(datetime__, datetime):
                date_ = datetime__.date()
            else:
                logger.error("Not known type of datetime get from database")
                raise VisualizerException("Not known type of datetime get from database")
            yield (date_, slot, file_size)
    except psycopg2.Error as e:
        logger.error("Error in reading the DB " + str(type(e)) + " : " + str(e))
        raise VisualizerException("Error in reading the DB " + str(type(e)) + " : " + str(e))
    conn.close()


def make_array(data_generator, date_start=date.today()-timedelta(60), date_end=date.today()+timedelta(10), slots_per_day=None):
    """Create the numpy array from the table
    :param data_generator: the generator of tuple (date, slot_integer, file_size) - no need of ordering
    :param slots_per_day: slots per day - if None, autodection is used
    :return: tuple (numpy array, (min_slot, max_slot)) where numpy array has shape (days, slots)"""
    timedelta_ = date_end - date_start  # get number of days to be shown
    day_to_show = timedelta_.days
    min_value= ""
    max_value=None

    if slots_per_day is not None:
        min_slot = 1
        max_slot = slots_per_day
    else:  # autodetect slots_per_day
        tmp_list = []
        slot_set = set()
        for row in data_generator:
            tmp_list.append(row)
            (aDate, slot, file_size) = row
            slot_set.add(slot)
        assert tmp_list, "NO data get from DB !"
        data_generator = iter(tmp_list)  # recycle iterated elements
        min_slot = min(slot_set)
        max_slot = max(slot_set)
        slots_per_day = max(max_slot - min_slot, len(slot_set)) + 1
    assert slots_per_day is not None, "Problem - slots count per day not detected yet!!!"

    result_matrix = np.zeros((day_to_show, slots_per_day), dtype="int32")  # create the 2D array
    for (aDate, slot, file_size) in data_generator:
        if aDate > date_end or aDate < date_start:
            logger.error("""There was day not between start and end point! You must have BAD DB query!!!
            The row:""" + str((aDate, slot, file_size)))
            raise VisualizerException("""There was day not between start and end point! You must have BAD DB query!!!
            The row:""" + str((aDate, slot, file_size)))
        day_index = (aDate - date_start).days
        result_matrix[day_index, slot-1] += file_size
        min_value = min(min_value, file_size)
        max_value = max(max_value, file_size)
    return result_matrix, (min_slot, max_slot, min_value, max_value)


# Pyplot stub

def create_pyplot_ui(np_array_2d, title_, min_slot, max_slot, date_start=date.today()-timedelta(60), date_end=date.today()+timedelta(10),
                figsize=(10, 8), dpi=100):
    """Make plot of given date and show with GUI
    :param np_array_2d: 2D array of data to be plotted
    :param date_start: datetime.datetime object specifying start
    :param date_end: datetime.datetime object specifying end
    :param figsize: tuple(w,h) in inches
    :param dpi: size for web, sizeInch * dpi = sizePixels
    :return: None if matlpotlib shown, or data if forWeb=True"""
    import matplotlib.pyplot as plt
    import matplotlib.cm as cm

    dfb_start = daytimeconv.date2dfb(date_start)
    dfb_end = daytimeconv.date2dfb(date_end)
    dfb_today = daytimeconv.date2dfb(date.today())

    fig = plt.figure(figsize=figsize, facecolor='w')
    ax = fig.add_subplot(111)
    np_array_2d_ = np_array_2d.transpose()
    b = ax.imshow(np.ma.masked_where(np_array_2d_==0, np_array_2d_), cmap=cm.RdYlGn, interpolation='nearest', origin='lower', )

    def format_coord(x, y):
        return 'x=%1.4f, y=%1.4f' % (x, y)

    ax.format_coord = format_coord

    ax.spines['left'].set_position(('outward', 10))
    ax.spines['bottom'].set_position(('outward', 10))
    df = np.arange(dfb_end+1-dfb_start)[::10]

    dates_s = [(date_start + timedelta(i)).strftime("%b-%d") for i in range(0, (date_end-date_start).days, 9)]
    plt.title(title_+"\n")
    ax.spines['left'].set_position(('axes', 0))
    ax.spines['right'].set_color('none')
    ax.spines['bottom'].set_position(('axes', 0))
    ax.spines['top'].set_color('none')

    slts = [i for i in range(145) if i % 16 == 0]
    # sltsl = [hm2slot(i, 0) for i in range(24) if i % 3 == 0]
    plt.yticks(slts, slts)

    plt.xticks(df.tolist(), dates_s, rotation=45)
    plt.axvline(x=dfb_today - dfb_start, )
    plt.colorbar(b)
    #plt.margins(0.05)
    ax.yaxis.set_ticks_position('left')
    ax.xaxis.set_ticks_position('bottom')
    plt.show()


def create_pyplot_web(np_array_2d, title_, min_slot, max_slot, date_start=date.today()-timedelta(60), date_end=date.today()+timedelta(10),
                figsize=(5, 4), dpi=100):
    """Make plot of given date and show with GUI
    :param np_array_2d: 2D array of data to be plotted
    :param date_start: datetime.datetime object specifying start
    :param date_end: datetime.datetime object specifying end
    :param figsize: tuple(w,h) in inches
    :param dpi: size for web, sizeInch * dpi = sizePixels
    :return: None if matlpotlib shown, or data if forWeb=True"""
    import matplotlib
    matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    import matplotlib.cm as cm
    import StringIO
    import urllib

    dfb_start = daytimeconv.date2dfb(date_start)
    dfb_end = daytimeconv.date2dfb(date_end)
    dfb_today = daytimeconv.date2dfb(date.today())

    fig = plt.figure(figsize=figsize, facecolor='w')
    ax = fig.add_subplot(111)
    np_array_2d_ = np_array_2d.transpose()
    b = ax.imshow(np.ma.masked_where(np_array_2d_==0, np_array_2d_), cmap=cm.RdYlGn, interpolation='nearest', origin='lower', )

    def format_coord(x, y):
        return 'x=%1.4f, y=%1.4f' % (x, y)

    ax.format_coord = format_coord

    ax.spines['left'].set_position(('outward', 10))
    ax.spines['bottom'].set_position(('outward', 10))
    #ax.set_ylim(-2, 129)
    dates = np.arange(dfb_start, dfb_end + 1)[::10]
    df = np.arange(dfb_end+1-dfb_start)[::10]
    # dates_s = [dfb2date(d).strftime('%b-%d') for d in dates]
    dates_s = dates
    plt.title(title_)
    ax.spines['left'].set_position(('axes', 0))
    ax.spines['right'].set_color('none')
    ax.spines['bottom'].set_position(('axes', 0))
    ax.spines['top'].set_color('none')

    slts = [i for i in range(145) if i % 16 == 0]
    # sltsl = [hm2slot(i, 0) for i in range(24) if i % 3 == 0]
    plt.yticks(slts, slts)

    plt.xticks(df.tolist(), dates_s, rotation=90)
    plt.axvline(x=dfb_today - dfb_start, )
    plt.colorbar(b)
    #plt.margins(0.05)
    ax.yaxis.set_ticks_position('left')
    ax.xaxis.set_ticks_position('bottom')
    imgdata = StringIO.StringIO()
    fig.savefig(imgdata, format='png', dpi=dpi)
    imgdata.seek(0)
    w, h = figsize
    return '<IMG src="data:image/png,' + urllib.quote(imgdata.getvalue()) + '" height="' + str(h * dpi) + 'px" width="' + str(w * dpi) + 'px">'


# ## SVG stub

def create_svg(np_array_2d, title_, min_slot, max_slot, min_value, max_value, date_start=date.today()-timedelta(60), date_end=date.today()+timedelta(10)):
    """Create the svg as text
    rows needs to be sorted yet by start_datetime ascending"""
    # constants for creating svg + labels in it
    width = 3
    height = 3
    nameX = "Slots"
    nameY = "Days"
    slots_numbers = ["" if i%10 else i for i in range(min_slot,max_slot+1)]

    days_count = (date_end - date_start).days
    day_labels = [str(date_start + timedelta(date_i)) + " -" for date_i in [0, days_count/4, days_count/2, 3*days_count/4, days_count]]
    # print("np_array_2d ", np_array_2d.shape)
    # for i,row in enumerate(np_array_2d):
    #     print(i,"row ",row)
    # return template.render(data=np_array_2d, width=width, height=height, nameChart=title_, nameX=nameX, nameY=nameY,
    #                        x_labels=day_labels, y_labels=slots_numbers, min_value=min_value, max_value=max_value)
    return template(data=np_array_2d, width=width, height=height, nameChart=title_, nameX=nameX, nameY=nameY,
                    x_labels=day_labels, y_labels=slots_numbers, min_value=min_value, max_value=max_value,
                    date_start=date_start, date_end=date_end)


def number_to_color(value, max_value, min_value):
    """Function converting value into color code
    :param value: value to convert into color
    :param max_value: max value for the range
    :param min_value: min value for the range
    :return: color code for given value"""
    if value is None:
        return "#DDDDDD"
    if value > max_value:
        return "#C00000"
    if value < min_value:
        return "#A0A0A0"
    r_min,g_min,b_min = (0,64,0)
    r_max,g_max,b_max = (255,117,0)
    r = r_min + float(r_max - r_min) * (value - min_value) / (max_value - min_value)
    g = g_min + float(g_max - g_min) * (value - min_value) / (max_value - min_value)
    b = b_min + float(b_max - b_min) * (value - min_value) / (max_value - min_value)
    return "#%02X%02X%02X"%(r,g,b)


def template(*args, **kwargs):
    """Function implementing the SVG template - this is rewrite from Jinja2 template using only python core stuff.
    There should be sent data ONLY in **kwargs manner. Required keys are: x_labels, y_labels, data (2D ndarray),
    max_value, min_value, date_start, date_end, (cell)width, (cell)height, nameChart, nameX, nameY"""
    assert len(args) == 0, "You gave me some *args !!!"
    assert len(kwargs), "You gave me NO **kwargs !!!"
    pl = parts_list = []

    x_labels = kwargs["x_labels"]
    y_labels = kwargs["y_labels"]
    data = kwargs["data"]
    max_value, min_value = kwargs["max_value"], kwargs["min_value"]
    date_start, date_end = kwargs["date_start"], kwargs["date_end"]
    kwargs["daysCount"], kwargs["slotsCount"] = data.shape
    kwargs["totalWidth"] = 25 + kwargs["daysCount"] * kwargs["width"] + 4 + 17 + 12
    kwargs["totalHeight"] = 12 + kwargs["slotsCount"] * kwargs["height"] + 70
    kwargs["dataWidth"] = 25 + kwargs["daysCount"] * kwargs["width"] + 4
    kwargs["dataHeight"] = kwargs["slotsCount"] * kwargs["height"]
    kwargs["middleX"] = kwargs["totalWidth"] / 2
    kwargs["nameY_y"] = kwargs["slotsCount"] * kwargs["height"] + 70

    pl.append("""<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#"
xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg"
xmlns="http://www.w3.org/2000/svg" viewBox = "0 0 {totalWidth} {totalHeight}" version="1.1"><g>""".format(**kwargs))
    pl.append("""<text x="{middleX}" y="12" style="font-size:15px;text-anchor: middle;">{nameChart}</text>""".format(**kwargs))
    pl.append("""<text x="8" y="37" font-size="12" transform="rotate(-90,8,37)">{nameX}</text>""".format(**kwargs))
    pl.append("""<text x="35" y="{nameY_y}" font-size="12">{nameY}</text>""".format(**kwargs))

    for day_No, day in enumerate(data):
        for slot_No, slot in enumerate(day):
            element = """<rect width="{width}" height="{height}" """.format(**kwargs)
            element +='desc="' + str(slot) + '" '
            element +='style="fill:' + number_to_color(slot, max_value, min_value) + '" '
            element +='x="' + str(day_No * kwargs["width"] + 25) + '" '
            element +='y="' + str(slot_No * kwargs["height"] + 20) + '"/>'
            pl.append(element)
    # Y labels
    for slot_label_No, slot_label in enumerate(y_labels):
        kwargs2 = {"y_position": 25 + kwargs["slotsCount"] * kwargs["height"] * slot_label_No / (len(y_labels)-1),
                   "slot_label": slot_label}
        pl.append("""<text x="8" y="{y_position}" font-size="10">{slot_label}</text>""".format(**kwargs2))
    # X labels
    for day_label_No, day_label in enumerate(x_labels):
        kwargs2 = {"x_position": 27 + kwargs["daysCount"] * kwargs["width"] * day_label_No / (len(x_labels) - 1),
            "y_position": kwargs["slotsCount"] * kwargs["height"] + 67,
            "day_label": day_label}
        pl.append("""<text x="{x_position}" y="{y_position}" font-size="9" transform="rotate(-90,{x_position},{y_position})">{day_label}</text>""".format(**kwargs2))

    # the blue line
    kwargs2 = { "x": (date.today() - date_start).days * kwargs["width"] + 25 + 3,
        "y2": kwargs["slotsCount"] * kwargs["height"] + 25}
    pl.append("""<line x1="{x}" y1="15" x2="{x}" y2="{y2}" style="stroke:rgb(0,0,255);stroke-width:0.5"/>""".format(**kwargs2))

    # the legend
    pl.append("""<defs>
    <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:rgb(0,64,0);stop-opacity:1" />
      <stop offset="100%" style="stop-color:rgb(255,117,0);stop-opacity:1" />
    </linearGradient>
  </defs>""")
    pl.append("""<rect width="11" height="{dataHeight}" x="{dataWidth}" y="20" fill="url(#grad1)"/>""".format(**kwargs))
    # the value labels on legend
    legend_label_list = [min_value, min_value+(max_value-min_value)/3, min_value+(max_value-min_value)*2/3, max_value]
    for i, value_label in enumerate(legend_label_list):
        element = '<text font-size="9" x="' +str(kwargs["dataWidth"] +12) +'" y="'
        element += str(20 +kwargs["dataHeight"]*i/(len(legend_label_list)-1)) +'">' +str(value_label) +'</text>'
        pl.append(element)

    pl.append("""</g></svg>""")  # finish the SVG file ;-)
    return "\n".join(parts_list)


# ## MAIN STUB
if __name__ == "__main__":
    main()
